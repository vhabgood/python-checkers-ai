--- a/main.py
+++ b/main.py
@@ -8,6 +8,7 @@
 import threading
 from datetime import datetime
 import random
+from engine.evaluation import evaluate_board_static
 from engine.constants import *
 
 # --- PART 1: THE CHECKERS GAME ENGINE (DEFINITIVE, CORRECTED VERSION) ---
@@ -165,34 +166,6 @@
         if len(red_kings) == 4 and len(white_kings) == 3:
             return (tuple(sorted(red_kings)), tuple(sorted(white_kings)), self.turn)
         return None
-
-    @staticmethod
-    def evaluate_board_static(board, turn_to_move):
-        gs = Checkers(board, turn_to_move, load_resources=False)
-        red_moves, white_moves = gs.get_all_possible_moves(RED), gs.get_all_possible_moves(WHITE)
-        red_jumps, white_jumps = any(abs(s[0]-e[0])==2 for s,e in red_moves), any(abs(s[0]-e[0])==2 for s,e in white_moves)
-        is_tactical = red_jumps or white_jumps
-
-        mat_score, pos_score = 0, 0
-        
-        for r, row in enumerate(board):
-            for c, piece in enumerate(row):
-                if piece == EMPTY: continue
-                
-                is_red = piece.lower() == RED
-                mat_score += Checkers.PIECE_VALUES[piece] if is_red else -Checkers.PIECE_VALUES[piece]
-                
-                if not is_tactical:
-                    if not piece.isupper():
-                        acf_pos = COORD_TO_ACF.get((r, c))
-                        if piece == RED and acf_pos in {1, 3}: pos_score += BACK_ROW_CORNER_BONUS
-                        elif piece == WHITE and acf_pos in {30, 32}: pos_score -= BACK_ROW_CORNER_BONUS
-                        
-        if not is_tactical:
-            red_kings = sum(row.count(RED_KING) for row in board)
-            white_kings = sum(row.count(WHITE_KING) for row in board)
-            if red_kings > 0 and white_kings == 0: pos_score += 0.5 * red_kings
-            elif white_kings > 0 and red_kings == 0: pos_score -= 0.5 * white_kings
-            
-        return (mat_score * MATERIAL_MULTIPLIER) + pos_score

     @staticmethod
     def _get_mvv_lva_score(board, move):
@@ -209,7 +182,7 @@
 
     def _static_quiescence_search(self, board, turn, alpha, beta, maximizing_player, eval_counter):
         eval_counter[0] += 1; game_state = Checkers(board, turn, load_resources=False)
-        capture_moves = [m for m in game_state.get_all_possible_moves(turn) if abs(m[0][0] - m[1][0]) == 2]
-        if not capture_moves: return self.evaluate_board_static(board, turn), []
+        capture_moves = [m for m in game_state.get_all_possible_moves(turn) if abs(m[0][0] - m[1][0]) == 2]
+        if not capture_moves: return evaluate_board_static(board, turn), []
         capture_moves.sort(key=lambda m: self._get_mvv_lva_score(board, m), reverse=True)
         if maximizing_player:
             best_value, best_path = -float('inf'), []
@@ -235,7 +208,7 @@
                 return entry['score'], entry['path']
 
         if depth == 0: return self._static_quiescence_search(board, turn, alpha, beta, maximizing_player, eval_counter)
-        game_state = Checkers(board, turn, load_resources=False)
-        if game_state.check_win_condition() is not None: return self.evaluate_board_static(board, turn), []
+        game_state = Checkers(board, turn, load_resources=False)
+        if game_state.check_win_condition() is not None: return evaluate_board_static(board, turn), []
         all_moves = game_state.get_all_possible_moves(turn)
-        if not all_moves: return self.evaluate_board_static(board, turn), []
+        if not all_moves: return evaluate_board_static(board, turn), []
         
         captures = [m for m in all_moves if abs(m[0][0] - m[1][0]) == 2]
         quiet_moves = [m for m in all_moves if abs(m[0][0] - m[1][0]) != 2]
@@ -252,7 +225,7 @@
                 
                 is_capture = abs(start[0] - end[0]) == 2
                 if depth <= 2 and not is_capture and not further_jumps and not any(abs(s[0]-e[0])==2 for s,e in temp_game.get_all_possible_moves(temp_game.turn)):
-                    static_eval = self.evaluate_board_static(temp_game.board, temp_game.turn)
+                    static_eval = evaluate_board_static(temp_game.board, temp_game.turn)
                     if static_eval + self.FUTILITY_MARGIN <= alpha:
                         continue
                 
@@ -271,7 +244,7 @@
                 
                 is_capture = abs(start[0] - end[0]) == 2
                 if depth <= 2 and not is_capture and not further_jumps and not any(abs(s[0]-e[0])==2 for s,e in temp_game.get_all_possible_moves(temp_game.turn)):
-                    static_eval = self.evaluate_board_static(temp_game.board, temp_game.turn)
+                    static_eval = evaluate_board_static(temp_game.board, temp_game.turn)
                     if static_eval - self.FUTILITY_MARGIN >= beta:
                         continue
 
@@ -321,7 +294,7 @@
     def _draw_info_panel(self, mouse_pos):
         panel_x, y = BOARD_SIZE+20, 20; panel_re = BOARD_SIZE+INFO_WIDTH-20
         self.screen.blit(self.font_medium.render("CHECKERS", True, COLOR_LIGHT), (panel_x, y)); y+=40
-        if self.game.winner: txt = f"Winner: {PLAYER_NAMES[self.game.winner]}!"; surf = self.font_large.render(txt,True,COLOR_CROWN)
+        if self.game.winner: txt = f"Winner: {self.game.winner}!"; surf = self.font_large.render(txt,True,COLOR_CROWN)
         else: txt = f"Turn: {PLAYER_NAMES[self.game.turn]}"; surf = self.font_medium.render(txt,True,COLOR_WHITE_P if self.game.turn==WHITE else COLOR_RED_P)
         self.screen.blit(surf, (panel_x, y)); y+=40
-        score = Checkers.evaluate_board_static(self.game.board,self.game.turn)/Checkers.MATERIAL_MULTIPLIER
+        score = evaluate_board_static(self.game.board,self.game.turn)/MATERIAL_MULTIPLIER
         adv = f"+{score:.2f} (Red Adv.)" if score>0.05 else f"{score:.2f} (White Adv.)" if score<-0.05 else "Even"
         self.screen.blit(self.font_small.render(f"Positional Score: {adv}",True,COLOR_LIGHT), (panel_x, y)); y+=25
         rm, rk, wm, wk = self.piece_counts
