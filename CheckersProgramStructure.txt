Checkers AI Program Structure (Updated)This document outlines the architecture of the checkers engine, reflecting the latest refactoring and feature additions.
======================================================================
FILE: main.py
CLASS: App
|
|-- METHOD: init(self, args)
|   
|  PURPOSE: Initializes Pygame, the main screen, and the state manager. Sets the initial state to the player selection screen.
|
|-- METHOD: main_loop(self)
|   
|  PURPOSE: The main loop of the application. Handles the event queue, file dialog requests, state updates, drawing, and transitions between the menu and the game.
|
|-- METHOD: _handle_state_transition(self)
|   
|  PURPOSE: Manages the switch from the main menu (PlayerSelectionScreen) to the main analysis board (CheckersGame).
======================================================================
FILE: game_states.py
CLASS: PlayerSelectionScreen
|
|-- METHOD: init(self, screen)
|   
|  PURPOSE: Initializes the main menu with a single "Start Analysis" button.
|
|-- METHOD: handle_event(self, event)
|   
|  PURPOSE: Listens for clicks on the "Start Analysis" button to transition to the game.
======================================================================
FILE: checkers_game.py
CLASS: CheckersGame
|  PURPOSE: A universal, flexible analysis board. This is the core of the UI, managing the board state, all user interactions, and the AI thinking process.
|
|-- METHOD: init(self, screen, status_queue, args)
|   
|  PURPOSE: Initializes the analysis board with a default player setup (Human vs. AI V1) and creates all UI buttons and state variables.
|
|-- METHOD: cycle_player(self, color)
|   
|  PURPOSE: The core of the flexible design. Cycles the controller for a given color between Human, AI V1, and AI V2.||-- METHOD: update(self)
|   
|  PURPOSE: The main logic loop for the game. Checks for AI moves, applies them, and enforces the pause and move delay logic.||-- METHOD: start_ai_turn(self)
|   
|  PURPOSE: Kicks off the AI's thinking process in a separate thread.||-- METHOD: load_fen_from_file(self, filepath)|   |  PURPOSE: Loads a board position from a .txt file containing FEN notation.
======================================================================
FILE: search.py
FUNCTION: get_ai_move_analysis(board, max_depth, color_to_move, evaluate_func)
|  PURPOSE: The top-level interface for the AI search. Manages the iterative deepening loop and the Aspiration Window logic.
FUNCTION: minimax(board, depth, alpha, beta, maximizing_player, evaluate_func)
|  PURPOSE: The core recursive search algorithm. Now implements a robust Principal Variation Search (PVS) with Late Move Reductions (LMR) and a History Heuristic for intelligent move ordering.FUNCTION: quiescence_search(board, alpha, beta, maximizing_player, evaluate_func)
|  PURPOSE: A specialized search that explores all capture sequences at the end of a main search to avoid the horizon effect.
======================================================================
FILE: evaluation.py
FUNCTION: _calculate_score(board, config)
|  PURPOSE: The AI's "brain". A single, powerful function that analyzes a board position based on a given configuration of weights.
FUNCTION: evaluate_board_v1(board)
|  PURPOSE: A wrapper that calls the core evaluator with the stable V1 weights.FUNCTION: evaluate_board_v2_experimental(board)
|  PURPOSE: A wrapper that calls the core evaluator with the new experimental V2 weights.
======================================================================
FILE: run_gauntlet.py
FUNCTION: run_gauntlet(args)
|  PURPOSE: The main function for the headless testing script. Loads all FEN positions, runs a match for each, and tallies the score.
CLASS: HeadlessGame
|  PURPOSE: A lightweight class that simulates a single checkers game between two AI engines without any GUI, used by the gauntlet.
======================================================================
STABLE FILES: (No recent major changes)
